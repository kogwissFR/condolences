#!/usr/bin/env python3
"""
Sync approved stories from Google Sheets to Jekyll data file.
Runs via GitHub Actions on schedule.
"""

import os
import json
import yaml
from datetime import datetime
import gspread
from oauth2client.service_account import ServiceAccountCredentials


def main():
    """Main execution function."""
    print("=" * 60)
    print("Kogni Memorial - Story Sync Script")
    print("=" * 60)
    
    # Load credentials from environment
    creds_json = os.environ.get('GOOGLE_CREDENTIALS')
    sheet_id = os.environ.get('SHEET_ID')
    
    if not creds_json or not sheet_id:
        print("ERROR: Missing required environment variables")
        print("Required: GOOGLE_CREDENTIALS, SHEET_ID")
        return 1
    
    try:
        # Authenticate with Google Sheets
        print("\n[1/5] Authenticating with Google Sheets...")
        creds_dict = json.loads(creds_json)
        scope = [
            'https://spreadsheets.google.com/feeds',
            'https://www.googleapis.com/auth/drive'
        ]
        creds = ServiceAccountCredentials.from_json_keyfile_dict(creds_dict, scope)
        client = gspread.authorize(creds)
        print("✓ Authentication successful")
        
        # Open spreadsheet
        print(f"\n[2/5] Opening spreadsheet (ID: {sheet_id[:20]}...)")
        sheet = client.open_by_key(sheet_id).sheet1
        print(f"✓ Opened sheet: {sheet.title}")
        
        # Get all records
        print("\n[3/5] Fetching all submissions...")
        records = sheet.get_all_records()
        print(f"✓ Found {len(records)} total submissions")
        
        # Filter approved stories
        print("\n[4/5] Processing approved stories...")
        approved_stories = []
        story_id = 1
        
        for idx, record in enumerate(records, 1):
            status = str(record.get('Status', '')).strip()
            
            if status == 'Approve':
                # Extract and clean data
                story = {
                    'id': f"{story_id:03d}",
                    'author_name': clean_string(record.get('Ihr Name (oder Pseudonym)', 'Anonym')),
                    'title': clean_string(record.get('Titel Ihrer Geschichte', '')),
                    'content': clean_string(record.get('Ihre Geschichte', '')),
                    'story_type': clean_string(record.get('Art der Einreichung', '')) or 'Nicht angegeben',
                    'submission_date': parse_date(record.get('Timestamp', '')),
                    'publication_date': parse_date(record.get('Moderation Date', '')) or datetime.now().strftime('%Y-%m-%d'),
                }
                
                # Add optional graduation year
                grad_year = record.get('Abschlussjahr (optional)', '')
                if grad_year:
                    try:
                        year = int(float(str(grad_year)))
                        if 1990 <= year <= 2029:
                            story['graduation_year'] = year
                    except (ValueError, TypeError):
                        pass
                
                # Validate required fields
                if story['title'] and story['content']:
                    if len(story['content']) >= 50:
                        approved_stories.append(story)
                        print(f"  ✓ Story {story_id}: '{story['title'][:50]}...' by {story['author_name']}")
                        story_id += 1
                    else:
                        print(f"  ✗ Row {idx}: Content too short ({len(story['content'])} chars)")
                else:
                    print(f"  ✗ Row {idx}: Missing required fields")
        
        print(f"\n✓ Processed {len(approved_stories)} approved stories")
        
        # Sort by publication date (newest first)
        approved_stories.sort(key=lambda x: x['publication_date'], reverse=True)
        
        # Write to YAML file
        print("\n[5/5] Writing to _data/stories.yml...")
        output_path = '_data/stories.yml'
        os.makedirs('_data', exist_ok=True)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("# This file is auto-generated by GitHub Actions\n")
            f.write("# Do not edit manually - changes will be overwritten\n")
            f.write(f"# Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
            f.write(f"# Total approved stories: {len(approved_stories)}\n\n")
            
            if approved_stories:
                yaml.dump(approved_stories, f, allow_unicode=True, default_flow_style=False, sort_keys=False)
            else:
                f.write("# No approved stories yet\n")
                f.write("[]\n")
        
        print(f"✓ Successfully wrote {len(approved_stories)} stories to {output_path}")
        print("\n" + "=" * 60)
        print("Sync completed successfully!")
        print("=" * 60)
        return 0
        
    except gspread.exceptions.APIError as e:
        print(f"\n✗ Google Sheets API Error: {e}")
        return 1
    except Exception as e:
        print(f"\n✗ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return 1


def clean_string(value):
    """Clean and sanitize string values."""
    if not value:
        return ''
    
    # Convert to string and strip whitespace
    text = str(value).strip()
    
    # Remove any null bytes
    text = text.replace('\x00', '')
    
    return text


def parse_date(date_str):
    """
    Parse various date formats from Google Sheets.
    Returns YYYY-MM-DD format or current date if parsing fails.
    """
    if not date_str:
        return None
    
    # Convert to string
    date_str = str(date_str).strip()
    
    if not date_str:
        return None
    
    # Try common formats
    formats = [
        '%Y-%m-%d',
        '%d/%m/%Y',
        '%m/%d/%Y',
        '%d.%m.%Y',
        '%Y-%m-%d %H:%M:%S',
        '%d/%m/%Y %H:%M:%S',
        '%m/%d/%Y %H:%M:%S',
        '%d.%m.%Y %H:%M:%S',
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime('%Y-%m-%d')
        except ValueError:
            continue
    
    # If all parsing fails, return current date
    print(f"  ⚠ Warning: Could not parse date '{date_str}', using current date")
    return datetime.now().strftime('%Y-%m-%d')


if __name__ == '__main__':
    exit_code = main()
    exit(exit_code)
